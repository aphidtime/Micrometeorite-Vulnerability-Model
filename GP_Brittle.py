import numpy as np
import csv
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
# from sklearn.preprocessing import normalize
from sklearn import preprocessing
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler, minmax_scale
import GP_Data_Modeling as gpM
import random as rand

df = pd.read_excel(io='Meteoroite_Impact_Regolith\Impact.xlsx', sheet_name='Regolith')
data=np.array(df)

test_labels = ["", "Test 1: Random", "Test 2: Max Speed", "Test 3: Min Speed"]

output_col = 2 # Change between 2 and 3
output_labels = ["Cratering Depth (cm)","Spalling Depth (cm)","",""]

Inputs =data[:,:2]
Outputs=data[:,output_col]


def data_splitter(data):
    counter = 0 
    split = []
    data_split = []
    value = -1

    for rows in data:
        if data[counter,1] != value: # Checks when value changes
            value = data[counter,1]
            # print(data[counter,1])
            split.append(counter)
            # print(counter)

        counter += 1
    split.append(counter) # Stores when split occurs
    # print((split))

    i = 0
    while i < (len(split) - 1): # Adds each split array to a list
        x = data[(split[i]):(split[i+1]),:]
        data_split.append(x)
        i += 1
    return data_split

def sample_pick(data, test):
    np.random.seed(1)
    if test == 1:
        # print("Length = ", len(data[:,0]))
        test_case = rand.randint(0, ((len(data[:,0])))) # Picks random value to remove
        # print("case: ", test_case)
    elif test == 2:
        # print(data[:,0])
        test_case = np.argmax(data[:,0], axis=0) # Finds largest speed value
        # print(test_case)
    elif test == 3:
        test_case = np.argmin(data[:,0], axis=0) # Finds smallest speed value
    elif test == 4:
        print("a")
    elif test == 5:
        print("a")

    elif test == 6:
        print("a")

    elif test == 7:
        print("a")
    return test_case, data

def prediction(data, output, expected, set):
    counter = output
    data_copy = data # making a copy for error testing
    data = np.delete(data, expected, 0)
    X = np.atleast_2d(data[:,0]).T
    x = np.atleast_2d(np.linspace(0, 1.2, 100)).T

    X_pred = np.atleast_2d(data_copy[:,0]).T # Values we are trying to predict and compare    
    y = data[:, counter]
    titles = ["","Plastic length- Front Plate (m)", "Plastic length-Back Plate(m)", "Penetration depth (m)", "Lip Height (m)"]

    # Instantiate a Gaussian Process model
    kernel = C(1.0, (1e-3, 1e3)) * RBF(10, (1e-2, 1e2)) # Used to define the model. Change around to test for better fits
    gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)

    # Fit to data using Maximum Likelihood Estimation of the parameters
    gp.fit(X, y)

    # Make the prediction on the meshed x-axis (ask for MSE as well)
    y_pred, sigma = gp.predict(x, return_std=True)

    y_pred, sigma_pred = gp.predict(X_pred, return_std=True)

    return y_pred

scaler = MinMaxScaler((0,1))
scaler.fit(data)
data = scaler.transform(data)
data = data_splitter(data)


data_formatted = data
print(data_formatted)

# expected, dataS = sample_pick(data_formatted,2)

# print(data_formatted)
# print(data_formatted[1])

# print(expected)

rms_values = []
 
test_set = []
test_case = 1


output = 0
while output < 2:
    output_case = output # Output that GP is modeling for
    set = 0 # start at the 1st set
    predicted_vals = []
    target_vals = []
    abs_error_set = []
    while set < len(data_formatted): # Run through all the sets of data
        expected, dataS = sample_pick(data_formatted[set],test_case)
        predicted = prediction(dataS, output_case, expected, set)
        predicted_vals.append(predicted[expected])
        target_vals.append(dataS[expected,(output_case+1)])
        # abs_error =  predicted[expected] - dataS[expected,(output_case+2)] # Finding abs error
        # abs_error_set.append(abs_error) # Adds value to list
        # print("set: ", set)
        set += 1
    abs_error_set = np.subtract(predicted_vals, target_vals)
    test_set.append(abs_error_set) # Adds each set of abs error to a list
    rms_values.append(gpM.rmse(predicted_vals, target_vals))
    output += 1

fig1, ax1 = plt.subplots()
ax1.set_title(test_labels[test_case])
ax1.boxplot(test_set[0:]) # Plot each output
plt.xticks([1, 2, 3, 4], output_labels, rotation = 0)
plt.xlabel("Outputs")
plt.show()

print(rms_values)
print("a") # Ending indicator
# print(data_formatted[8])
