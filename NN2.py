import scipy.io as sp
from numpy import shape
import numpy as np
from sklearn.preprocessing import MinMaxScaler, minmax_scale
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score
import pandas as pd
import pandas as pd

######################################################################


df = pd.read_excel(io='Meteoroite_Impact_Regolith\Impact.xlsx', sheet_name='Regolith')
data=np.array(df)

######################################################################

# scaler = MinMaxScaler((0,1))
# scaler.fit(data[:,:2])
# Inputs = scaler.transform(data[:,:2])
# Outputs=data[:,2]

###########################################################################


Inputs =data[:,:2]
Outputs=data[:,2]

scaler = MinMaxScaler((0,1))
scaler.fit(Inputs)
Inputs = scaler.transform(Inputs)

#####################################################################################

def Split(a,b, test_size):
    x_train, x_test, y_train, y_test=train_test_split(a,b,test_size=test_size)
    return x_train, x_test, y_train, y_test


x_train, x_test, y_train, y_test = Split(Inputs,Outputs,0.2)

    
#############################################################################




if __name__=="__main__":
    

    
    # build model
    model=tf.keras.Sequential([
        tf.keras.layers.Dense(4,input_dim=2, activation="relu"),
        tf.keras.layers.Dense(20, activation="relu"),
        tf.keras.layers.Dense(20, activation="relu"),
        tf.keras.layers.Dense(1)
    ])
    
    # compile model
    optimiser=tf.keras.optimizers.Adam(learning_rate=0.002)
    model.compile(optimizer=optimiser, loss="MSE")
    
    # train model
    model.fit(x_train, y_train, epochs=1800,verbose=1)
    
    # evaluate model
    print("\nModel evaluation:")
    model.evaluate(x_test, y_test, verbose=1)

    
  ####################################################################################  
    
    def R_squared(y, y_pred):
        residual = tf.reduce_sum(tf.square(tf.subtract(y, y_pred)))
        total = tf.reduce_sum(tf.square(tf.subtract(y, tf.reduce_mean(y))))
        r2 = tf.subtract(1.0, tf.div(residual, total))
        return r2
    predictions_test = model.predict(x_test)
    predictions_train = model.predict(x_train)
    
    Comparison=np.zeros((9,2))
    Comparison[:,0]=predictions_test[:,0]
    Comparison[:,1]=y_test
    aa=r2_score(y_test,predictions_test)
    bb=r2_score(y_train,predictions_train)
    



    print('r2_test:',aa)
    print('r2_train:',bb)
    print(Comparison)
    
    print("prediction train: ")
    print(predictions_train)
    
    









