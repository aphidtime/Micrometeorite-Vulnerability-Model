function [Y,Xf,Af] = myNeuralNetworkFunctionDuctile(X,~,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 20-Apr-2022 15:26:19.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = Qx3 matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = Qx1 matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0;0;0];
x1_step1.gain = [2;2;2];
x1_step1.ymin = -1;

% Layer 1
b1 = [-2.4498463400900076792;-2.6021562941553808557;1.8549660476776166362;-1.1370038028262972052;-0.87073215711776996706;-0.7292507576396523028;-1.1873563345807660596;1.766393896383141815;2.5970794249193165371;2.9766316434391759671];
IW1_1 = [1.1138905710966660045 -2.5859992440612411535 2.7818554388077521011;1.1666309092443012396 2.1006049725311752852 -1.5820895258814213769;-1.9738366275475942579 1.8828707365700116938 1.9463379531450266668;2.0477182723580651391 -0.85056464217988336785 1.3362629460486912247;1.1188969193302074068 2.2141055889279002145 1.57805505120880607;-2.3618277472551376661 -1.6270756704566928796 2.101251401995505752;-2.5175954760648022734 -0.23987180924863396592 1.5040606684227375567;0.59024318110795248593 2.8658346362574933508 -0.58643212504568320576;2.7569125378828918116 0.60779856769687656826 0.16571980336644320797;2.2676113937209727567 2.6494232513669562223 -0.04772593701733071625];

% Layer 2
b2 = -0.40245463985522872408;
LW2_1 = [0.10017710539506465006 -0.023394971801228320318 0.19653324900757795923 0.52251187546290389641 0.083791897564703093915 0.13171388938500419585 -0.19376953977981553612 0.08385712182735755027 0.48974224956740797232 -0.39017916969287785856];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 2;
y1_step1.xoffset = 0;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
    X = {X};
end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},1); % samples/series
else
    Q = 0;
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    X{1,ts} = X{1,ts}';
    Xp1 = mapminmax_apply(X{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
    Y{1,ts} = Y{1,ts}';
end

% Final Delay States
Xf = cell(1,0);
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
    Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
