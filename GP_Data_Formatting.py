import numpy as np
import csv
from matplotlib import pyplot as plt

from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
# from sklearn.preprocessing import normalize
from sklearn import preprocessing

# Import raw data 
# data_raw = np.genfromtxt('C:/Users/andyl/Documents/school/PurdueY1Summer/ME Summer Project/GP models/Aluminum Abaqus Jobs - MOST RECENT JOBS LIST.csv', delimiter=',')

# Transform and format data to use
def data_transform(data):
    np.nan_to_num(data, copy=False, nan=0.0, posinf=None, neginf=None) # convert NaNs to 0
    data1 = np.delete(data, np.s_[-3:-1], 1) # last 3 empty columns
    data1 = np.delete(data1, (0,4,7,-1), 1) # columns with no change in value/non-numerical
    data1 = np.delete(data1, np.s_[0:2], 0) # first 2 rows with the labels
    return data1

def data_normalize(data):
    high = 1
    low = 0
    mins = np.min(data, axis=0)
    maxs = np.max(data, axis=0)
    rng = maxs - mins
    normalized =  high - (((high - low) * (maxs - data)) / rng)
    return normalized

# Split data into individual sets
def data_splitter(data):
    counter = 0 
    split = []
    data_split = []
    value = 1

    for rows in data:
        if data[counter,1] != value: # Checks when value changes
            value = data[counter,1]
            # print(data[counter,1])
            split.append(counter)
            # print(counter)

        counter += 1
    split.append(counter) # Stores when split occurs
    # print((split))

    i = 0
    while i < (len(split) - 1): # Adds each split array to a list
        x = data[(split[i]):(split[i+1]),:]
        data_split.append(x)
        i += 1
    return data_split

# data_T = data_transform(data_raw)
# # np.savetxt("foo.csv", data_T, delimiter=",") # Check if data was trimmed correctly
# data_formatted = data_splitter(data_T)

def back_perf_remove_max(data):
    counter = 0
    remove = []
    for rows in data:
        if data[counter,1] == data[counter,5]:
            remove.append(counter)
        counter += 1
    data = np.delete(data, remove, 0)
    print(data)
    return data

def back_perf_remove_min(data):
    counter = 0
    remove = []
    for rows in data:
        if data[counter,4] != 0:
            remove.append(counter)
        # else:
            # print(data[counter,4])
        counter += 1
    data = data[remove]
    return data

def data_transform_classification(data):
    np.nan_to_num(data, copy=False, nan=0.0, posinf=None, neginf=None) # convert NaNs to 0
    data1 = np.delete(data, np.s_[-3:-1], 1) # last 3 empty columns
    data1 = np.delete(data1, (0,4), 1) # columns with no change in value/non-numerical
    data1 = np.delete(data1, np.s_[0:2], 0) # first 2 rows with the labels
    return data1